---
layout: post
title: Comment les EIG et les mentors apprennent et progressent ?
author: Bastien Guerry, EIG Link
twitter: bzg2
description: "Au printemps dernier, les EIG et les mentors se sont retrouvés pour une session d'accompagnement au cours de laquelle deux ateliers ont été organisés autour d'une question simple : comment apprenons-nous ? quelles stratégies pour progresser dans la résolution des problèmes ?"
---

## 4 démarches sur la façon d'apprendre et de progresser

Au printemps dernier, les EIG et les mentors se sont retrouvés pour
une session d'accompagnement au cours de laquelle deux ateliers ont
été organisés autour d'une question simple : comment apprenons-nous ?
quelles stratégies pour progresser dans la résolution des problèmes ?

L'informatique, c'est un ensemble de connaissances, théoriques et
pratiques, et d'outils pour les mettre en oeuvre.  Les *designers*,
les développeurs et les datascientistes sont constamment en train
d'apprendre : un nouveau langage, un outil, de nouvelles façons
d'aborder un problème.  Dans le contexte du programme EIG, il y a de
surcroît une autre dimension importante : celle de la familiarisation
avec les métiers des services administratifs dans lesquels les EIG
sont immergés.  Tout cela nous a incité à partager nos expériences,
le tout de façon très directe et personnelle.

<br/>
<a title="© XKCD - CC-by-sa-nc 2.5" href="https://xkcd.com/1205/"><img src="https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png"/></a>
<p><em>Combien de temps travailler pour automatiser une tâche routinière ? - © XKCD - CC-by-sa-nc 2.5</em></p>

Les retours des uns et des autres se sont faits à bâton rompu, dans
une conversation collective.  Mais plutôt qu'une liste à la Prévert de
conseils et de principes, nous présentons ici une synthèse proposant
quatre démarches.

## Les démarches : analytique, pratique, empathique, pédagogique

- **Think small!** ou la démarche *analytique* : il s'agit ici de
  réduire les éléments à apprendre à leur taille adéquate, en avançant
  pas à pas.  Le livre de référence serait ici le *Discours de la
  méthode* de notre René Descartes international.
  
- **Think real!** ou la démarche *pratique* : il s'agit là d'apprendre
  en faisant, les mains dans le cambouis.  Le livre de référence
  serait [The Pragmatic
  Programmer](https://en.wikipedia.org/wiki/The_Pragmatic_Programmer)
  de Andrew Hunt et David Thomas ou l'[Éloge du
  carburateur](https://www.editionsladecouverte.fr/catalogue/index-_loge_du_carburateur-9782707160065.html)
  de Matthieu Crawford.

- **Think different!** ou la démarche *empathique* : comment renforcer
  ses connaissances en apprenant à les remettre en cause, comment
  résoudre un problème en se plaçant du point de vue d'une autre
  personne.  Les ressources à invoquer ici iraient de la démarche
  [Lean](https://fr.wikipedia.org/wiki/Lean_(production)) à la
  [vidéo](https://www.youtube.com/watch?v=PsgBtOVzHKI) où Richard
  Feynman nous encourage à voir les choses autrement.
  
- **Think again!** ou la démarche *pédagogique* : comment apprendre en
  échangeant, en expliquant ?  Comment créer les bonnes boucles de
  rétroaction pour s'assurer à la fois de progresser pas à pas et de
  revenir facilement sur les solutions qu'on se donne ?  Le mentor
  serait ici *Rich Hickey* et son insistance sur [la différence entre
  simplicité et
  facilité](https://www.youtube.com/watch?v=34_L7t7fD_U), et sur [le
  besoin permanent de
  recul](https://www.youtube.com/watch?v=f84n5oFoZBc).

<img src="/img/apprendre_progresser.png"/>
<p><em>Devoirs à la maison : remplir les intersections ! © Bastien Guerry - CC-by-sa 4.0</em></p>

## En vrac et en détail

Ce découpage est forcément un peu factice, mais servons-nous en pour
lister l'ensemble des retours collectés lors de ces ateliers.

### *Think small!*

- *Don't repeat yourself!* : l'idée est d'éviter de rédiger du code
  redondant et de modulariser le plus possible.
- *Small is beautiful* : faire des modules petits, avec des fonctions
  précises.  Apprendre par éléments
- *Less is more* : apprendre à faire *moins*.
- *Do one thing and do it well* : la pierre angulaire de la
  philosophie Unix pour le *design* de ses outils.
- *Avoir un cahier d'apprentissage* : pour ne pas avoir à rechercher
  ailleurs ce qu'on a déjà découvert.
- *Se discipliner* : Ne pas partir dans des grands plans ambitieux
  mais se forcer à rester au plus près d'éléments digestes.

### *Think real!*

- *Résoudre des problèmes authentiques* : pas des problèmes
  potentiels, juste pour la forme.  Se jeter dans le grand bain.
- *The importance of being earnest* : le titre d'une comédie d'Oscar
  Wilde mais aussi un principe régulièrement cité, pour ne pas
  sous-estimer ou surestimer ses capacités.
- *Avoir un bon mentor* : quelqu'un qui peut nous aider à tester nos
  connaissances et nos compétences.
- *Faire les choses soi-même* : apprendre à se débrouiller en toutes
  circonstances.
- *Mettre tout en oeuvre pour une fin particulière* : ne pas aborder
  un problème avec une seule solution toute faite, mais tout faire
  pour résoudre les problèmes.
- *Avoir un profil d'apprentissage en T* : être excellent dans un
  domaine précis et renforcer sa culture générale dans les autres.
- *La meilleure méthode, c'est de ne pas en avoir* : ne pas rester
  dans le « méta », mais foncer et mettre tout son savoir-faire pour
  proposer une solution.

### *Think different!*

- *Step back* : Apprendre à prendre du recul, loin du clavier.
- *Encourager la complémentarité dans les équipes* : l'écoute mutuelle
  de points de vue complémentaires fait mieux avancer.
- *Parler à sa brosse à dent* : quand on est bloqué, formuler le
  problème à haute voix aide à avoir les idées claires.
- *Lire du code* : plonger dans le code de quelqu'un aide à aborder
  d'autres façons de résoudre un problème.
- *Revenir aux fondamentaux* : le retour aux fondamentaux aide à
  prendre du recul.
- *S'aérer l'esprit* : une pause dehors avec un peu de sport nous fait
  changer de point de vue, et c'est parfois l'occasion pour le cerveau
  d'envisager les problèmes sous un autre angle.
- *Avoir des projets de code personnels* : de tels projets permettent
  d'expérimenter et de sortir de sa zone de confort technique.
- *Hammoc driven development* : la proposition de Rich Hickey pour
  s'assurer qu'on aborde le problème de la bonne façon.
- *Changer de tâches* : On bloque sur une question ?  Vidons-nous
  l'esprit avec d'autres tâches le temps de revenir au problème
  initial avec les idées fraîches.

### *Think again!*

- *Trouver sa boucle de rétroaction* : écrire et tester.  Ce sont à
  peu près les deux activités principales d'un développeur.  Trouver
  sa boucle de rétroaction, c'est trouver la façon la plus efficace et
  rapide de faire cela.
- *Fail early* : il faut échouer tôt pour réparer tôt.
- *Enjoy often* : le plaisir est un élément indispensable de la
  motivation, c'est lui qui renforce les boucles de rétroaction
  productives.
- *Apprendre à apprendre* : introduire de la réflexivité non seulement
  dans nos activités de développeurs mais aussi dans notre attitude
  générale à l'égard de la façon dont on apprend et progresse.  Le
  cours en ligne « [Learning How to
  Learn](https://fr.coursera.org/learn/learning-how-to-learn) » a été
  cité plusieurs fois.

## « Apprenez à programmer en 10 ans ! »

<a href="https://pxhere.com/en/photo/911144"><img
src="https://c.pxhere.com/photos/72/9c/close_up_code_coding_computer_computing_conceptual_data_design-911144.jpg!d"/></a>
<p><em>Des lignes de code.  Who cares ?</em></p>

Vous avez vu l'image ci-dessus bien souvent fois mais elle donne une
idée fausse de ce qui nous paraît réellement difficile dans nos
métiers techniques : ce n'est pas d'aligner des lignes de code, c'est
de comprendre tous les aspects d'un projet et de ne jamais cesser
d'apprendre !  Le développement de projet informatique est une tâche
complexe, aux multiples dimensions, où l'expérience compte au moins
autant que les connaissances techniques.  Il n'y pas de recette toute
prête, pas de *silver bullet*.  Sur ce sujet, la deuxième promotion du
programme EIG nous a permis de renforcer deux convictions : rien de
plus efficace qu'**un cadre qui invite à apprendre et progresser** et
rien de plus plaisant que d'**apprendre à plusieurs** !

« Apprenez à programmer en 10 ans ! », c'est le titre d'[un article de
Peter Norvig](http://www.norvig.com/21-days.html), souvent cité en
réaction aux slogans faciles du genre « Apprenez le langage X en 10
jours ! ».  C'est à ça que nous croyons : le temps long.

 
